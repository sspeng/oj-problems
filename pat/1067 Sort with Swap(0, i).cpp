#include <cstdio>
#include <vector>
using namespace std;

/*
 * 这个题有很多需要考虑的点啊，我慢慢道来。本题采用的算法是典型的
 * 贪心策略，具体说来分为两种情况
 *
 * 1. if pos[0] != 0, swap(0, pos[0])
 * 2. if pos[0] == 0, swap(0, k) 其中 k 是从左至右第一个未就位
 *    的元素。
 *
 * 该策略的证明可以用循环节来阐述。循环节具有若干性质：
 *
 * 1. 前 N 个自然数组成的序列由若干循环节组成。这些循环节之间是
 *    相互独立的，否则这些循环节都会退化成为一个。
 * 2. 交换不同循环节的两个元素，将使这两个循环节合并成一个。
 * 
 * 因此，对于含有元素0的多元循环节，一共需要 n - 1 次交换，使所有
 * 元素归位。多于不含元素0的多元循环节，则首先需要进行一次交换，使
 * 0进入该循环节，因此一共需要 n + 1 次交换。这样，就产生了另一种
 * 策略，即统计不同类型循环节的数量，就可以直接得到答案。该策略与上
 * 面的策略是完全一致的。现在说明该策略是最优的：
 *
 * 如果 pos[0] != 0，则一次交换都会使一个非零元素归位。反之，则要
 * 进行一次「空操作」，使得 pos[0] != 0。故该策略需要的交换次数大约
 * 是所有未就位元素的个数加上空操作的次数（减1）。每存在一个循环节
 * 就需要一次这样的「空操作」，使该循环节包含0，因此上面的策略已数
 * 最优。
 *
 * 在实现过程中我还存在一些问题，比如 k 的选择，每次我都是做一次从
 * 左到右的遍历，但是这样的话时间复杂度就激增至 O(n^2)，两个测试点
 * 会超时。更优的策略是记录下每次选择的 k，后续就从前面保存的 k 继续
 * 向前遍历，该策略正确的原因是除零以外的就位元素不会再受到修改。
 * 这样内层循环就至多进行 N 次，时间复杂度也降到了 O(n)。
 */

void swap(int& one, int& two){
	int tmp;
	tmp = one;
	one = two;
	two = tmp;
}

int main(){
	int N, curr, ix, count, k;    // k denotes first non-pivot element
	scanf("%d", &N);
	vector<int> pos(N);
	for(ix = 0; ix != N; ++ix){
		scanf("%d", &curr);
		pos[curr] = ix;
	}
	count = 0, k = 0;
	while(true){
		if(pos[0] == 0){
			while(k < N){
				if(pos[k] != k) break;
				++k;
			}
			if(k == N) break;
			swap(pos[0], pos[k]);
			++count;
		}
		else{
			swap(pos[0], pos[pos[0]]);
			++count;
		}
	}
	printf("%d\n", count);
	return 0;
}
